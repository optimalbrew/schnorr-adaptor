package main

import (
	"crypto/ecdsa"
	"crypto/rand"
	"fmt"
	"math/big"

	"github.com/ethereum/go-ethereum/crypto"
)

func main() {
	// Get the elliptic curve parameters
	curveParams := crypto.S256().Params()

	// Generate Alice's private key
	alicePrivateKey, err := crypto.GenerateKey()
	if err != nil {
		fmt.Println("Error generating Alice's private key:", err)
		return
	}
	alicePublicKey := &alicePrivateKey.PublicKey

	// Message to be signed (for the adaptor signature)
	message1 := []byte("This is message 1")

	// Message for the adapted signature (could be the same or different)
	// This is not used, and was generated by Gemini, perhaps as a reminder that the adaptor signature is not tied to a specific message.
	// however, when used for different msg, care needs to be taken about relation between the two messages.
	//message2 := []byte("This is message 2")

	// Generate a random nonce 'k'
	k, err := rand.Int(rand.Reader, curveParams.N)
	if err != nil {
		fmt.Println("Error generating nonce:", err)
		return
	}

	// Compute the nonce point R = kG
	// There are warnings in this code for deprecated function ScalarBaseMult, but as per Gemini, we are not performing ECDH.
	// .. We're using scalar multiplication as a fundamental part of the Schnorr signature algorithm itself.
	/* Here's the warning:
	crypto.S256().ScalarBaseMult is deprecated: this is a low-level unsafe API. For ECDH, use the crypto/ecdh
	package. Most uses of ScalarBaseMult can be replaced by a call to the
	PrivateKey.PublicKey method in crypto/ecdh.
	*/
	Rx, Ry := crypto.S256().ScalarBaseMult(k.Bytes())

	// Generate the adaptor secret 't'
	t, err := rand.Int(rand.Reader, curveParams.N)
	if err != nil {
		fmt.Println("Error generating adaptor secret:", err)
		return
	}

	// Hash the relevant information to create the challenge 'e'
	hash := crypto.Keccak256Hash(Rx.Bytes(), Ry.Bytes(), crypto.FromECDSAPub(alicePublicKey), message1)
	e := new(big.Int).SetBytes(hash.Bytes())
	e.Mod(e, curveParams.N)

	// Compute the adaptor signature component s' = k - e * x - t (mod n)
	eMulX := new(big.Int).Mul(e, alicePrivateKey.D)
	sPrime := new(big.Int).Sub(k, eMulX)
	sPrime.Sub(sPrime, t)
	sPrime.Mod(sPrime, curveParams.N)

	adaptorSignature := struct {
		R *ecdsa.PublicKey
		S *big.Int
	}{
		R: &ecdsa.PublicKey{
			Curve: crypto.S256(),
			X:     Rx,
			Y:     Ry,
		},
		S: sPrime,
	}

	fmt.Printf("Adaptor Signature (R.X, R.Y, S'): (%x, %x, %x)\n", adaptorSignature.R.X, adaptorSignature.R.Y, adaptorSignature.S)

	// Alice reveals the secret 't' to Bob

	// Bob adapts the signature: s_adapted = s' + t (mod n)
	sAdapted := new(big.Int).Add(adaptorSignature.S, t)
	sAdapted.Mod(sAdapted, curveParams.N)

	adaptedSignature := struct {
		R *ecdsa.PublicKey
		S *big.Int
	}{
		R: adaptorSignature.R,
		S: sAdapted,
	}

	fmt.Printf("Adapted Signature (R.X, R.Y, S_adapted): (%x, %x, %x)\n", adaptedSignature.R.X, adaptedSignature.R.Y, adaptedSignature.S)

	// Verification of the adapted signature on message1
	// Verification of the adapted signature on message1
	hashVerify := crypto.Keccak256Hash(adaptedSignature.R.X.Bytes(), adaptedSignature.R.Y.Bytes(), crypto.FromECDSAPub(alicePublicKey), message1)
	eVerify := new(big.Int).SetBytes(hashVerify.Bytes())
	eVerify.Mod(eVerify, curveParams.N)

	// Verify s*G + e*P == R
	sGx, sGy := crypto.S256().ScalarBaseMult(adaptedSignature.S.Bytes())
	ePx, ePy := crypto.S256().ScalarMult(alicePublicKey.X, alicePublicKey.Y, eVerify.Bytes())

	RxVerify := new(big.Int)
	RyVerify := new(big.Int)
	RxVerify, RyVerify = crypto.S256().Add(sGx, sGy, ePx, ePy) // Use the curve's Add function

	if RxVerify.Cmp(adaptedSignature.R.X) == 0 && RyVerify.Cmp(adaptedSignature.R.Y) == 0 {
		fmt.Println("Adapted signature is valid on message1!")
	} else {
		fmt.Println("Adapted signature is NOT valid on message1!")
	}
}
